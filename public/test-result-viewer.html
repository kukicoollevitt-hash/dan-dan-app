<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>진단테스트 시험지 보기</title>
  <!-- PDF 생성을 위한 라이브러리 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- 카카오 SDK -->
  <script src="https://developers.kakao.com/sdk/js/kakao.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Noto Sans KR", sans-serif;
      background: #f5f5f5;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 2px solid #667eea;
    }

    .header h1 {
      font-size: 24px;
      color: #2c3e50;
      margin-bottom: 15px;
    }

    .student-info {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
      margin-top: 15px;
    }

    .info-badge {
      display: inline-block;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
    }

    .info-badge.name {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .info-badge.grade {
      background: #e8f4fd;
      color: #3498db;
    }

    .info-badge.score {
      background: #27ae60;
      color: white;
    }

    .info-badge.result-grade {
      font-size: 16px;
    }

    .grade-S { background: #ffd700; color: #333; }
    .grade-A { background: #ff6b6b; color: white; }
    .grade-B { background: #4ecdc4; color: white; }
    .grade-C { background: #95e1d3; color: #333; }
    .grade-D { background: #e0e0e0; color: #666; }

    .summary {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
    }

    .summary-item {
      text-align: center;
      padding: 15px 25px;
      background: #f8f9fa;
      border-radius: 12px;
    }

    .summary-item .label {
      font-size: 14px;
      color: #666;
      margin-bottom: 5px;
    }

    .summary-item .value {
      font-size: 20px;
      font-weight: 700;
      color: #2c3e50;
    }

    .summary-item .value.correct {
      color: #27ae60;
    }

    .summary-item .value.wrong {
      color: #e74c3c;
    }

    /* 틀린 문항 바로가기 */
    .wrong-questions-nav {
      background: #fff5f5;
      border: 2px solid #e74c3c;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .wrong-questions-nav h4 {
      color: #e74c3c;
      font-size: 16px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .wrong-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .wrong-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      background: #e74c3c;
      color: white;
      border-radius: 50%;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none;
    }

    .wrong-badge:hover {
      background: #c0392b;
      transform: scale(1.1);
    }

    /* 맨 위로 가기 버튼 */
    .scroll-to-top {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .scroll-to-top.visible {
      opacity: 1;
      visibility: visible;
    }

    .scroll-to-top:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
    }

    /* AI 피드백 섹션 */
    .ai-feedback-section {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 16px;
      padding: 25px;
      margin-bottom: 20px;
      color: white;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }

    .ai-feedback-section h4 {
      font-size: 20px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .ai-feedback-loading {
      text-align: center;
      padding: 30px;
    }

    .ai-feedback-loading .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .ai-feedback-content {
      display: none;
    }

    .feedback-card {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 18px;
      margin-bottom: 15px;
      backdrop-filter: blur(10px);
    }

    .feedback-card:last-child {
      margin-bottom: 0;
    }

    .feedback-card-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 10px;
      opacity: 0.9;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .feedback-card-content {
      font-size: 15px;
      line-height: 1.7;
      word-break: keep-all;
    }

    .ai-feedback-error {
      text-align: center;
      padding: 20px;
      display: none;
    }

    .ai-feedback-error button {
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid white;
      color: white;
      padding: 10px 25px;
      border-radius: 25px;
      font-size: 14px;
      cursor: pointer;
      margin-top: 15px;
      transition: all 0.3s ease;
    }

    .ai-feedback-error button:hover {
      background: white;
      color: #667eea;
    }

    /* 과목별 정답률 막대 그래프 */
    .skill-bar-chart {
      background: white;
      border-radius: 12px;
      padding: 25px;
      margin-bottom: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
    }

    .skill-bar-chart h4 {
      font-size: 18px;
      color: #2c3e50;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .skill-bar-item {
      margin-bottom: 15px;
    }

    .skill-bar-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 14px;
      font-weight: 600;
    }

    .skill-bar-label .name {
      color: #2c3e50;
    }

    .skill-bar-label .percent {
      color: #667eea;
    }

    .skill-bar-bg {
      width: 100%;
      height: 24px;
      background: #e9ecef;
      border-radius: 12px;
      overflow: visible;
      position: relative;
    }

    .skill-bar-fill {
      height: 100%;
      border-radius: 12px;
      transition: width 0.8s ease;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 8px;
      font-size: 12px;
      font-weight: 600;
      color: white;
    }

    .skill-bar-fill.excellent { background: linear-gradient(90deg, #27ae60, #2ecc71); }
    .skill-bar-fill.good { background: linear-gradient(90deg, #3498db, #5dade2); }
    .skill-bar-fill.average { background: linear-gradient(90deg, #f39c12, #f1c40f); }
    .skill-bar-fill.poor { background: linear-gradient(90deg, #e74c3c, #ec7063); }

    /* 학년 평균 기준선 */
    .grade-avg-line {
      position: absolute;
      top: -4px;
      height: 32px;
      width: 2px;
      background: #2c3e50;
      z-index: 10;
    }

    .grade-avg-label {
      position: absolute;
      top: -20px;
      transform: translateX(-50%);
      font-size: 10px;
      font-weight: 600;
      color: #2c3e50;
      white-space: nowrap;
      background: #fff;
      padding: 1px 4px;
      border-radius: 3px;
    }

    .grade-avg-info {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 15px;
      padding: 10px 15px;
      background: #f8f9fa;
      border-radius: 8px;
      font-size: 13px;
      color: #555;
    }

    .grade-avg-info .avg-marker {
      display: inline-block;
      width: 20px;
      height: 2px;
      background: #2c3e50;
      vertical-align: middle;
    }

    .question-list {
      margin-top: 30px;
    }

    .question-item {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      border-left: 4px solid #667eea;
    }

    .question-item.correct {
      border-left-color: #27ae60;
      background: #f0fff4;
    }

    .question-item.wrong {
      border-left-color: #e74c3c;
      background: #fff5f5;
    }

    .question-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .question-number {
      font-size: 16px;
      font-weight: 700;
      color: #667eea;
    }

    .question-category {
      display: flex;
      gap: 8px;
    }

    .category-badge {
      padding: 4px 12px;
      border-radius: 15px;
      font-size: 12px;
      font-weight: 600;
      background: #e8f4fd;
      color: #3498db;
    }

    .skill-badge {
      padding: 4px 12px;
      border-radius: 15px;
      font-size: 12px;
      font-weight: 600;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .result-icon {
      font-size: 24px;
    }

    .passage-box {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 12px;
      line-height: 1.7;
      font-size: 14px;
      color: #555;
      border-left: 3px solid #667eea;
    }

    .question-text {
      font-size: 15px;
      font-weight: 600;
      color: #2c3e50;
      margin-bottom: 12px;
    }

    .options-list {
      list-style: none;
    }

    .option-item {
      padding: 10px 15px;
      margin-bottom: 8px;
      border-radius: 8px;
      font-size: 14px;
      color: #555;
      background: white;
      border: 2px solid transparent;
    }

    .option-item.correct-answer {
      background: #d4edda;
      border-color: #27ae60;
      color: #155724;
    }

    .option-item.user-wrong {
      background: #f8d7da;
      border-color: #e74c3c;
      color: #721c24;
    }

    .option-item.user-correct {
      background: #d4edda;
      border-color: #27ae60;
      color: #155724;
    }

    .option-marker {
      font-weight: 700;
      margin-right: 8px;
    }

    .answer-info {
      display: flex;
      gap: 20px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #ddd;
      font-size: 14px;
    }

    .answer-info span {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .explanation-box {
      margin-top: 12px;
      padding: 12px;
      background: #e8f4fd;
      border-radius: 8px;
      font-size: 13px;
      color: #555;
      line-height: 1.6;
    }

    .explanation-box strong {
      color: #2c3e50;
    }

    .loading {
      text-align: center;
      padding: 50px;
      font-size: 18px;
      color: #667eea;
    }

    .error {
      text-align: center;
      padding: 50px;
      font-size: 18px;
      color: #e74c3c;
    }

    .print-btn {
      display: block;
      width: 100%;
      max-width: 300px;
      margin: 30px auto 0;
      padding: 15px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .print-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
    }

    .action-buttons {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    .pdf-btn, .kakao-btn {
      padding: 15px 30px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .pdf-btn {
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      color: white;
    }

    .pdf-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(231, 76, 60, 0.4);
    }

    .kakao-btn {
      background: #FEE500;
      color: #191919;
    }

    .kakao-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(254, 229, 0, 0.6);
    }

    @media print {
      body {
        background: white;
        padding: 0;
      }
      .container {
        box-shadow: none;
        padding: 20px;
      }
      .print-btn, .action-buttons {
        display: none;
      }
      .question-item {
        break-inside: avoid;
      }
    }

    @media (max-width: 600px) {
      .container {
        padding: 15px;
      }
      .header h1 {
        font-size: 20px;
      }
      .student-info {
        flex-direction: column;
        align-items: center;
      }
      .summary {
        flex-direction: column;
      }
      .strength-weakness {
        grid-template-columns: 1fr;
      }
    }

    /* 레이더 차트 스타일 */
    .radar-chart-container {
      background: white;
      padding: 30px;
      border-radius: 20px;
      margin: 30px 0;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      text-align: center;
    }

    .radar-chart-container h3 {
      font-size: 24px;
      color: #2c3e50;
      margin-bottom: 25px;
      font-weight: 700;
    }

    .radar-chart-container canvas {
      max-width: 100%;
      height: auto;
      margin: 0 auto;
      display: block;
    }

    /* 추천 시리즈 박스 */
    .recommendation-box {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      padding: 35px;
      border-radius: 20px;
      margin-bottom: 30px;
      border: 3px solid #667eea;
      text-align: center;
    }

    .recommendation-box h3 {
      font-size: 26px;
      color: #2c3e50;
      margin-bottom: 20px;
      font-weight: 700;
    }

    .series-badge {
      display: inline-block;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 35px;
      border-radius: 30px;
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 20px;
    }

    .recommendation-text {
      font-size: 17px;
      color: #34495e;
      line-height: 1.8;
      margin-bottom: 15px;
    }

    /* 강점/성장 영역 */
    .strength-weakness {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 30px;
      margin-bottom: 30px;
    }

    .strength-box, .weakness-box {
      padding: 25px;
      border-radius: 15px;
      text-align: left;
    }

    .strength-box {
      background: #d4edda;
      border-left: 5px solid #28a745;
    }

    .weakness-box {
      background: #fff3cd;
      border-left: 5px solid #ffc107;
    }

    .strength-box h4, .weakness-box h4 {
      font-size: 18px;
      margin-bottom: 12px;
      font-weight: 600;
    }

    .strength-box h4 {
      color: #155724;
    }

    .weakness-box h4 {
      color: #856404;
    }

    .strength-box p, .weakness-box p {
      font-size: 15px;
      line-height: 1.6;
      margin: 0;
    }

    .strength-box p {
      color: #155724;
    }

    .weakness-box p {
      color: #856404;
    }

    /* 분석 섹션 구분선 */
    .analysis-section {
      margin: 30px 0;
      padding-top: 30px;
      border-top: 2px dashed #dee2e6;
    }

    .section-title {
      font-size: 20px;
      font-weight: 700;
      color: #2c3e50;
      margin-bottom: 20px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="loading" class="loading">시험지를 불러오는 중...</div>
    <div id="error" class="error" style="display: none;"></div>
    <div id="content" style="display: none;">
      <div class="header">
        <h1>문해력 진단테스트 결과지</h1>
        <div class="student-info" id="studentInfo"></div>
      </div>

      <div class="summary" id="summary"></div>

      <!-- 레이더 그래프 -->
      <div class="radar-chart-container">
        <h3>📊 5가지 문해력 지수 분석</h3>
        <canvas id="radarChart" width="500" height="500"></canvas>
      </div>

      <!-- 추천 시리즈 -->
      <div class="recommendation-box">
        <h3>💡 추천 시리즈</h3>
        <div class="series-badge" id="recommendedSeries"></div>
        <p class="recommendation-text" id="recommendationText"></p>
      </div>

      <!-- 강점/성장 영역 -->
      <div class="strength-weakness">
        <div class="strength-box">
          <h4>✅ 강점 영역</h4>
          <p id="strengthText"></p>
        </div>
        <div class="weakness-box">
          <h4>💪 성장 영역</h4>
          <p id="weaknessText"></p>
        </div>
      </div>

      <!-- 문해력 지수별 정답률 막대 그래프 -->
      <div class="skill-bar-chart" id="skillBarChart">
        <h4>📊 문해력 지수별 정답률</h4>
        <div id="skillBarContainer"></div>
      </div>

      <!-- 과목별 정답률 막대 그래프 -->
      <div class="skill-bar-chart" id="categoryBarChart">
        <h4>📚 과목별 정답률</h4>
        <div id="categoryBarContainer"></div>
      </div>

      <!-- AI 맞춤 피드백 섹션 -->
      <div class="ai-feedback-section" id="aiFeedbackSection">
        <h4>🤖 AI 맞춤 분석 피드백</h4>

        <div class="ai-feedback-loading" id="aiFeedbackLoading">
          <div class="spinner"></div>
          <p>AI가 결과를 분석하고 있어요...</p>
        </div>

        <div class="ai-feedback-content" id="aiFeedbackContent">
          <div class="feedback-card">
            <div class="feedback-card-title">🎯 종합 평가</div>
            <div class="feedback-card-content" id="feedbackOverall"></div>
          </div>
          <div class="feedback-card">
            <div class="feedback-card-title">💪 강점 분석</div>
            <div class="feedback-card-content" id="feedbackStrengths"></div>
          </div>
          <div class="feedback-card">
            <div class="feedback-card-title">📈 성장 포인트</div>
            <div class="feedback-card-content" id="feedbackImprovements"></div>
          </div>
          <div class="feedback-card">
            <div class="feedback-card-title">💡 학습 TIP</div>
            <div class="feedback-card-content" id="feedbackTips"></div>
          </div>
        </div>

        <div class="ai-feedback-error" id="aiFeedbackError">
          <p>피드백을 불러오지 못했어요 😢</p>
          <button onclick="loadAIFeedback()">다시 시도</button>
        </div>
      </div>

      <!-- 틀린 문항 바로가기 -->
      <div class="wrong-questions-nav" id="wrongQuestionsNav" style="display: none;">
        <h4>❌ 틀린 문항 바로가기</h4>
        <div class="wrong-badges" id="wrongBadges"></div>
      </div>

      <!-- 문제 오답/정답 해설 섹션 -->
      <div class="analysis-section">
        <h3 class="section-title">📝 문제별 정답 및 해설</h3>
      </div>

      <div class="question-list" id="questionList"></div>

      <button class="print-btn" onclick="window.print()">인쇄하기</button>

      <div class="action-buttons">
        <button class="pdf-btn" onclick="downloadPDF()">
          📄 PDF 다운로드
        </button>
        <button class="kakao-btn" onclick="sendKakao()">
          💬 카카오톡 전송하기
        </button>
      </div>
    </div>
  </div>

  <script>
    // 퀴즈 데이터 (25문항 - 5개 지문 × 5개 문해력 지수)
    const quizData = [
      // ========== 사회 (1-5) ==========
      {
        category: "사회",
        skill: "핵심 이해력",
        passage: "최근 우리나라는 저출산 고령화 사회로 급속히 진입하고 있다. 통계청에 따르면 2023년 합계출산율은 0.72명으로 역대 최저치를 기록했으며, 65세 이상 고령 인구는 전체 인구의 18%를 넘어섰다. 이러한 인구 구조의 변화는 경제 성장 둔화, 사회보장비용 증가, 노동력 감소 등 다양한 사회 문제를 야기할 것으로 예상된다. 정부는 출산 장려 정책과 고령층 일자리 창출을 통해 이 문제를 해결하려 노력하고 있지만, 구조적 문제 해결에는 장기적 접근이 필요하다.",
        question: "이 글의 중심 내용으로 가장 적절한 것은?",
        options: [
          "우리나라 통계청의 역할과 기능",
          "저출산 고령화의 원인과 해결 방안",
          "저출산 고령화 현상과 그로 인한 사회적 영향",
          "정부의 출산 장려 정책의 성공 사례"
        ],
        correct: 2,
        explanation: "이 글은 저출산 고령화 현상을 통계로 제시하고, 이로 인해 발생하는 경제 성장 둔화, 사회보장비용 증가, 노동력 감소 등의 사회적 영향을 설명하고 있습니다. 정부의 정책도 언급하지만 핵심은 현상과 그 영향입니다."
      },
      {
        category: "사회",
        skill: "구조 파악력",
        passage: "다문화 가정이 증가하면서 한국 사회의 문화적 다양성이 확대되고 있다. 2023년 기준 국내 다문화 가족 구성원은 약 130만 명에 달한다. 그러나 언어 장벽과 문화적 차이로 인한 갈등도 존재한다. 정부는 한국어 교육과 문화 적응 프로그램을 지원하고, 지역사회는 다문화 축제를 개최하여 상호 이해를 증진하고 있다. 전문가들은 다문화 공생 사회로 나아가기 위해서는 제도적 지원과 함께 시민들의 인식 개선이 필수적이라고 강조한다.",
        question: "이 글의 논리적 전개 방식은?",
        options: [
          "현상 제시 → 통계 제시 → 문제점 설명 → 해결 노력 및 한계 언급",
          "문제 제기 → 원인 분석 → 해결책 제시 → 결과 예측",
          "주장 제시 → 반론 제시 → 재반론 → 결론",
          "사례 나열 → 공통점 도출 → 일반화"
        ],
        correct: 0,
        explanation: "이 글은 다문화 가정 증가라는 현상을 제시한 후 통계(130만 명)를 제시하고, 언어 장벽과 문화적 차이라는 문제점을 설명합니다. 이어서 정부와 지역사회의 해결 노력을 설명하며, 마지막으로 제도적 지원만으로는 부족하다는 한계를 언급하고 있습니다."
      },
      {
        category: "사회",
        skill: "어휘 맥락력",
        passage: "디지털 격차는 정보 접근 능력에 따라 사회적 불평등이 심화되는 현상을 말한다. 고령층과 저소득층은 스마트폰이나 컴퓨터 활용 능력이 부족해 온라인 금융, 행정 서비스 이용에 어려움을 겪는다. 이로 인해 일상생활에서 불편함을 느끼고, 경제적 기회도 제한받는다. 이를 완화하기 위해 정부는 무료 디지털 교육 프로그램을 운영하고, 공공기관은 오프라인 창구를 유지하는 등 다양한 노력을 기울이고 있다.",
        question: "문맥상 '완화하다'의 의미로 가장 적절한 것은?",
        options: [
          "강화하다",
          "줄이거나 약하게 만들다",
          "제거하다",
          "분석하다"
        ],
        correct: 1,
        explanation: "문맥상 '완화하다'는 디지털 격차로 인한 문제를 줄이거나 약하게 만든다는 의미입니다. 정부가 교육 프로그램을 운영하고 오프라인 창구를 유지하는 것은 문제를 완전히 제거하는 것이 아니라 그 심각성을 줄이기 위한 노력입니다."
      },
      {
        category: "사회",
        skill: "추론 통합력",
        passage: "최근 청년 실업률이 높아지면서 청년층의 경제적 어려움이 사회 문제로 대두되고 있다. 취업 준비 기간이 길어지고, 비정규직 비율도 증가하는 추세다. 이로 인해 결혼과 출산을 미루는 청년들이 늘어나고, 주거 불안정성도 심화되고 있다. 정부는 청년 일자리 창출과 주거 지원 정책을 추진하고 있으나, 구조적 문제 해결을 위해서는 교육 시스템 개편과 기업의 채용 문화 변화가 동반되어야 한다는 지적이 나온다.",
        question: "이 글을 통해 추론할 수 있는 내용으로 가장 적절한 것은?",
        options: [
          "청년 실업은 단기간에 완전히 해결될 수 있다",
          "청년 실업 문제는 다양한 사회 문제와 연결되어 있다",
          "비정규직 증가는 청년들에게 긍정적이다",
          "정부 정책만으로 모든 문제가 해결된다"
        ],
        correct: 1,
        explanation: "글에서 청년 실업이 결혼, 출산, 주거 불안정성 등 다양한 사회 문제로 연결되어 있음을 보여줍니다. 또한 정부 정책만이 아니라 교육 시스템, 기업 문화 등 여러 요소가 함께 변화해야 한다는 점에서 문제의 복합성을 알 수 있습니다."
      },
      {
        category: "사회",
        skill: "비판 적용력",
        passage: "플라스틱 쓰레기 문제가 심각해지면서 환경 보호를 위한 실천이 강조되고 있다. 일회용 플라스틱 사용을 줄이고, 분리배출을 철저히 하며, 재활용품을 적극 활용하는 것이 중요하다. 기업들도 친환경 포장재 사용을 확대하고, 정부는 일회용품 규제를 강화하고 있다. 그러나 개인의 작은 실천이 모여야 큰 변화를 만들 수 있으며, 환경 문제 해결을 위해서는 모든 사회 구성원의 참여가 필수적이다.",
        question: "이 글의 내용을 바탕으로 개인이 실천할 수 있는 방안으로 가장 적절하지 않은 것은?",
        options: [
          "장바구니와 텀블러 사용하기",
          "분리배출을 철저히 하기",
          "일회용품을 더 많이 사용하기",
          "재활용 제품 구매하기"
        ],
        correct: 2,
        explanation: "글에서는 '일회용 플라스틱 사용을 줄이고'라고 명시하고 있으므로, 일회용품을 더 많이 사용하는 것은 환경 보호 실천과 정반대되는 행동입니다. 장바구니와 텀블러 사용, 분리배출, 재활용 제품 구매는 모두 글에서 권장하는 실천 방안입니다."
      },
      // ========== 과학 (6-10) ==========
      {
        category: "과학",
        skill: "핵심 이해력",
        passage: "광합성은 식물이 빛 에너지를 화학 에너지로 전환하는 과정이다. 엽록체 내의 엽록소가 태양 빛을 흡수하면, 물과 이산화탄소를 원료로 포도당과 산소를 만들어낸다. 이 과정은 명반응과 암반응 두 단계로 나뉘는데, 명반응에서는 빛 에너지로 ATP와 NADPH를 생성하고, 암반응에서는 이들을 이용해 탄수화물을 합성한다. 광합성으로 생산된 포도당은 식물의 성장에 필요한 에너지원이 되며, 배출된 산소는 지구 생명체의 호흡에 필수적이다.",
        question: "이 글에서 설명하는 광합성의 핵심 기능은?",
        options: [
          "산소를 이산화탄소로 전환하는 과정",
          "빛 에너지를 화학 에너지로 전환하는 과정",
          "식물이 물을 흡수하는 과정",
          "동물이 에너지를 얻는 과정"
        ],
        correct: 1,
        explanation: "글의 첫 문장에서 '광합성은 식물이 빛 에너지를 화학 에너지로 전환하는 과정'이라고 명확히 정의하고 있습니다. 빛 에너지를 받아 포도당(화학 에너지)을 만드는 것이 광합성의 핵심 기능입니다."
      },
      {
        category: "과학",
        skill: "구조 파악력",
        passage: "DNA는 유전 정보를 저장하는 생명체의 설계도이다. DNA는 이중나선 구조로 되어 있으며, 아데닌(A), 티민(T), 구아닌(G), 사이토신(C) 네 가지 염기로 구성된다. 이 염기들은 특정 규칙에 따라 쌍을 이룬다. A는 T와, G는 C와 결합한다. DNA 복제 과정에서는 이중나선이 풀리고, 각 가닥이 주형이 되어 새로운 가닥이 합성된다. 이러한 구조 덕분에 유전 정보가 정확하게 다음 세대로 전달될 수 있다.",
        question: "DNA 복제 과정의 단계별 순서로 올바른 것은?",
        options: [
          "새 가닥 합성 → 이중나선 풀림 → 주형 형성",
          "주형 형성 → 새 가닥 합성 → 이중나선 풀림",
          "이중나선 풀림 → 각 가닥이 주형이 됨 → 새 가닥 합성",
          "염기 결합 → 주형 형성 → 이중나선 풀림"
        ],
        correct: 2,
        explanation: "글에서 DNA 복제 과정을 순서대로 설명하고 있습니다. 먼저 '이중나선이 풀리고', 그 다음 '각 가닥이 주형이 되어', 마지막으로 '새로운 가닥이 합성된다'는 세 단계를 명확히 제시하고 있습니다."
      },
      {
        category: "과학",
        skill: "어휘 맥락력",
        passage: "지구 온난화는 대기 중 온실가스 농도가 증가하여 지구 평균 기온이 상승하는 현상이다. 이산화탄소, 메탄 등의 온실가스는 태양 복사열을 흡수하여 지구를 따뜻하게 유지하는 역할을 한다. 그러나 산업화 이후 화석 연료 사용이 급증하면서 온실가스 배출량이 과도하게 증가했다. 이로 인해 빙하가 녹고, 해수면이 상승하며, 이상 기후 현상이 빈번해지고 있다. 기후 변화를 억제하기 위해서는 탄소 배출을 줄이는 것이 시급하다.",
        question: "문맥상 '억제하다'의 의미로 가장 적절한 것은?",
        options: [
          "가속화하다",
          "막거나 줄이다",
          "관찰하다",
          "증가시키다"
        ],
        correct: 1,
        explanation: "문맥상 '기후 변화를 억제하기 위해 탄소 배출을 줄인다'고 했으므로, '억제하다'는 부정적인 현상을 막거나 줄인다는 의미입니다. 탄소 배출을 줄이는 것이 기후 변화를 억제하는 방법이라는 점에서 확인할 수 있습니다."
      },
      {
        category: "과학",
        skill: "추론 통합력",
        passage: "항생제는 세균 감염을 치료하는 약물이다. 그러나 항생제를 과도하게 사용하거나 처방된 기간보다 짧게 복용하면 내성균이 생길 수 있다. 내성균은 항생제에 저항성을 가진 세균으로, 일반 항생제로는 치료가 어렵다. 최근 항생제 내성 문제가 심각해지면서, 세계보건기구(WHO)는 항생제 오남용을 경고하고 있다. 항생제는 반드시 의사의 처방에 따라 정확한 용량과 기간을 지켜 복용해야 한다.",
        question: "이 글을 바탕으로 추론할 수 있는 내용은?",
        options: [
          "항생제는 모든 질병을 치료할 수 있다",
          "항생제를 많이 먹을수록 효과가 좋다",
          "항생제를 잘못 사용하면 치료가 더 어려워질 수 있다",
          "내성균은 항생제 복용과 관련이 없다"
        ],
        correct: 2,
        explanation: "글에서 항생제를 잘못 사용하면 내성균이 생기고, 내성균은 일반 항생제로는 치료가 어렵다고 설명합니다. 따라서 항생제를 잘못 사용하면 나중에 질병 치료가 더 어려워질 수 있다는 것을 추론할 수 있습니다."
      },
      {
        category: "과학",
        skill: "비판 적용력",
        passage: "인공지능(AI) 기술이 발전하면서 의료, 교육, 산업 등 다양한 분야에서 활용되고 있다. AI는 방대한 데이터를 빠르게 분석하여 인간보다 정확한 예측을 할 수 있다. 그러나 AI의 판단 근거가 불투명하고, 편향된 데이터로 학습할 경우 잘못된 결과를 낼 수 있다는 우려도 있다. 또한 일자리 감소와 개인 정보 침해 문제도 제기된다. 따라서 AI 기술 발전과 함께 윤리적 기준과 규제 마련이 필요하다.",
        question: "AI 기술 활용 시 고려해야 할 사항으로 적절하지 않은 것은?",
        options: [
          "데이터의 편향성 검토",
          "개인 정보 보호",
          "윤리적 기준 마련",
          "모든 결정을 AI에게만 맡기기"
        ],
        correct: 3,
        explanation: "글에서 AI의 판단 근거가 불투명하고 편향된 데이터로 잘못된 결과를 낼 수 있다고 경고하고 있습니다. 따라서 모든 결정을 AI에게만 맡기는 것은 위험하며, 인간의 검토와 윤리적 기준이 함께 필요합니다."
      },
      // ========== 인문 (11-15) ==========
      {
        category: "인문",
        skill: "핵심 이해력",
        passage: "칸트는 '순수이성비판'에서 인간의 인식 능력을 체계적으로 분석했다. 그는 경험론과 합리론의 대립을 극복하기 위해, 인간의 인식이 감각 경험과 선천적 인식 형식의 결합으로 이루어진다고 주장했다. 즉, 우리가 세계를 인식하는 방식은 대상 자체가 아니라 우리의 인식 구조에 의해 결정된다는 것이다. 이를 '코페르니쿠스적 전회'라 부르며, 이는 철학사에서 인식론의 패러다임을 전환시킨 혁명적 사고였다.",
        question: "이 글이 설명하는 칸트 철학의 핵심 주장은?",
        options: [
          "인식은 오직 감각 경험으로만 가능하다",
          "인식은 순수한 이성만으로 가능하다",
          "인식은 감각 경험과 선천적 형식의 결합으로 이루어진다",
          "인식은 대상 자체를 있는 그대로 파악한다"
        ],
        correct: 2,
        explanation: "글에서 칸트는 경험론(감각 경험)과 합리론(순수 이성)의 대립을 극복하기 위해, 인식이 '감각 경험과 선천적 인식 형식의 결합'으로 이루어진다고 주장했다고 명확히 설명하고 있습니다. 이것이 칸트 철학의 핵심 주장입니다."
      },
      {
        category: "인문",
        skill: "구조 파악력",
        passage: "사르트르는 '실존은 본질에 앞선다'는 명제로 실존주의 철학을 정립했다. 그는 인간은 태어날 때 정해진 본질이 없으며, 스스로의 선택과 행동을 통해 자신의 본질을 만들어간다고 보았다. 따라서 인간은 자신의 삶에 대해 전적인 책임을 져야 한다. 이러한 자유와 책임은 불안을 동반하지만, 동시에 인간 존재의 위대함을 보여준다. 사르트르는 이를 통해 수동적 삶이 아닌 주체적 실존을 강조했다.",
        question: "이 글의 논리 전개 방식으로 가장 적절한 것은?",
        options: [
          "핵심 명제 제시 → 의미 설명 → 결론(강조점) 제시",
          "주장 → 반대 의견 → 재반론 → 결론",
          "현상 나열 → 원인 분석 → 결과 예측",
          "시대순 역사적 사건 나열"
        ],
        correct: 0,
        explanation: "글은 먼저 '실존은 본질에 앞선다'는 핵심 명제를 제시하고, 이어서 그 의미(인간이 선택으로 본질을 만들어감, 자유와 책임)를 설명한 후, 마지막으로 주체적 실존이라는 강조점을 제시하는 구조입니다."
      },
      {
        category: "인문",
        skill: "어휘 맥락력",
        passage: "공자는 '논어'에서 인(仁)을 핵심 덕목으로 강조했다. 인은 타인에 대한 사랑과 배려를 의미하며, '자기가 원하지 않는 것을 남에게 베풀지 말라'는 서(恕)의 정신으로 구현된다. 또한 공자는 예(禮)를 통해 사회 질서를 유지하고, 학문을 통해 인격을 도야할 것을 주장했다. 이러한 유교 사상은 동아시아 문화에 깊은 영향을 미쳐 현재까지도 사회적 가치관의 기반이 되고 있다.",
        question: "문맥상 '도야하다'의 의미로 가장 적절한 것은?",
        options: [
          "파괴하다",
          "닦고 기르다",
          "숨기다",
          "버리다"
        ],
        correct: 1,
        explanation: "문맥상 '학문을 통해 인격을 도야한다'는 것은 학문을 통해 인격을 발전시키고 향상시킨다는 긍정적 의미입니다. 따라서 '도야하다'는 '닦고 기르다'는 의미로, 인격을 수양하고 발전시키는 것을 뜻합니다."
      },
      {
        category: "인문",
        skill: "추론 통합력",
        passage: "르네상스는 14세기부터 16세기까지 유럽에서 일어난 문화 운동으로, '재생'을 의미한다. 중세 신 중심 사상에서 벗어나 인간 중심의 사고가 확산되었고, 고대 그리스·로마 문화가 재발견되었다. 예술에서는 원근법과 인체 표현이 발전했고, 학문에서는 실험과 관찰을 중시하는 과학적 방법이 등장했다. 르네상스는 근대 사회로 나아가는 중요한 전환점이 되었다.",
        question: "이 글을 바탕으로 추론할 수 있는 내용은?",
        options: [
          "르네상스는 중세 사상을 그대로 계승했다",
          "르네상스는 인간의 이성과 창조성을 강조했다",
          "르네상스 시기에는 예술이 쇠퇴했다",
          "르네상스는 과학 발전과 무관하다"
        ],
        correct: 1,
        explanation: "글에서 르네상스는 신 중심에서 인간 중심 사고로 전환되었고, 예술에서 원근법과 인체 표현이 발전했으며, 실험과 관찰을 중시하는 과학적 방법이 등장했다고 설명합니다. 이를 통해 르네상스가 인간의 이성과 창조성을 강조한 시기였음을 추론할 수 있습니다."
      },
      {
        category: "인문",
        skill: "비판 적용력",
        passage: "플라톤은 '국가론'에서 이상 국가를 제시하며, 통치자는 철학자여야 한다고 주장했다. 그는 진리를 아는 자만이 올바른 통치를 할 수 있다고 보았다. 그러나 이러한 철인 통치론은 현실적으로 실현 가능성이 낮고, 권력 남용의 위험이 있다는 비판을 받는다. 현대 민주주의는 권력 분립과 견제를 통해 이러한 문제를 해결하려 한다. 그럼에도 플라톤의 사상은 통치자의 자질과 윤리에 대한 중요한 질문을 던진다.",
        question: "플라톤의 철인 통치론을 현대 사회에 적용할 때 시사점으로 적절한 것은?",
        options: [
          "소수의 철학자에게 모든 권력을 집중해야 한다",
          "통치자의 윤리와 자질은 중요하지 않다",
          "리더의 도덕성과 전문성이 중요하다",
          "민주주의는 불필요하다"
        ],
        correct: 2,
        explanation: "플라톤의 철인 통치론은 권력 집중의 위험성 때문에 그대로 적용할 수 없지만, 글의 마지막 문장에서 '통치자의 자질과 윤리에 대한 중요한 질문을 던진다'고 했듯이, 현대에도 리더의 도덕성과 전문성이 중요하다는 시사점을 얻을 수 있습니다."
      },
      // ========== 경제 (16-20) ==========
      {
        category: "경제",
        skill: "핵심 이해력",
        passage: "인플레이션은 물가가 지속적으로 상승하는 현상을 말한다. 중앙은행은 인플레이션을 조절하기 위해 기준금리를 조정하는데, 금리를 인상하면 돈의 가치가 올라가고 대출이 줄어들어 소비와 투자가 감소한다. 반대로 금리를 인하하면 경기가 활성화되지만 물가 상승 압력이 커진다. 적정 수준의 인플레이션(연 2% 내외)은 경제 성장에 긍정적이지만, 과도한 인플레이션은 화폐 가치 하락과 구매력 감소를 초래해 경제 불안을 야기한다.",
        question: "이 글의 중심 내용은?",
        options: [
          "중앙은행의 역사와 발전 과정",
          "인플레이션의 개념과 금리를 통한 조절 방식",
          "물가 상승의 긍정적 효과만 설명",
          "경제 성장률 계산 방법"
        ],
        correct: 1,
        explanation: "이 글은 인플레이션이 무엇인지 정의한 후, 중앙은행이 기준금리 인상과 인하를 통해 인플레이션을 조절하는 방식을 설명하고 있습니다. 적정 수준과 과도한 수준의 차이도 언급하며 인플레이션 조절의 중요성을 강조합니다."
      },
      {
        category: "경제",
        skill: "구조 파악력",
        passage: "수요와 공급의 법칙은 시장경제의 기본 원리다. 수요가 공급보다 많으면 가격이 상승하고, 공급이 수요보다 많으면 가격이 하락한다. 예를 들어, 농작물 흉년으로 공급이 감소하면 가격이 올라가고, 반대로 풍년으로 공급이 늘어나면 가격이 내려간다. 시장은 이러한 가격 메커니즘을 통해 자원을 효율적으로 배분한다. 그러나 독과점이나 정보 비대칭 같은 시장 실패가 발생하면 정부 개입이 필요하다.",
        question: "수요와 공급의 관계에 따른 가격 변동 순서로 올바른 것은?",
        options: [
          "수요 증가 → 공급 증가 → 가격 하락",
          "공급 감소 → 수요 증가 → 가격 상승",
          "공급 증가 → 수요 감소 → 가격 상승",
          "수요 증가 → 공급 감소 → 가격 하락"
        ],
        correct: 1,
        explanation: "글에서 '수요가 공급보다 많으면 가격이 상승한다'고 설명합니다. 공급이 감소하고 수요가 증가하면 수요가 공급을 크게 초과하므로 가격이 상승하게 됩니다. 이는 흉년의 예시에서도 확인할 수 있습니다."
      },
      {
        category: "경제",
        skill: "어휘 맥락력",
        passage: "주식은 기업의 소유권을 나타내는 증권이다. 주식을 보유하면 기업의 이익에 따라 배당금을 받을 수 있고, 주가가 상승하면 자본 이득을 얻을 수 있다. 그러나 기업 실적이 나빠지면 주가가 하락하여 손실을 볼 수도 있다. 주식 투자는 높은 수익을 기대할 수 있지만, 그만큼 변동성도 크다. 따라서 투자자는 분산 투자를 통해 위험을 완화하고, 장기적 관점에서 접근하는 것이 중요하다.",
        question: "문맥상 '완화하다'의 의미로 가장 적절한 것은?",
        options: [
          "증폭시키다",
          "줄이거나 약하게 만들다",
          "무시하다",
          "강화하다"
        ],
        correct: 1,
        explanation: "문맥상 '분산 투자를 통해 위험을 완화한다'는 것은 한 곳에 집중 투자할 때의 큰 위험을 여러 곳에 나누어 투자함으로써 줄이거나 약하게 만든다는 의미입니다. 위험을 제거하는 것이 아니라 그 정도를 낮추는 것입니다."
      },
      {
        category: "경제",
        skill: "추론 통합력",
        passage: "최저임금제는 근로자의 생활 안정을 위해 임금의 최저 수준을 법으로 정하는 제도다. 최저임금이 인상되면 저소득 근로자의 소득이 증가하여 생활이 개선될 수 있다. 그러나 기업의 인건비 부담이 커져 고용이 감소하거나, 가격 인상으로 이어질 수 있다는 우려도 있다. 최저임금 정책은 근로자 보호와 경제 활력 사이의 균형을 고려하여 신중하게 결정해야 한다.",
        question: "이 글로부터 추론할 수 있는 내용은?",
        options: [
          "최저임금 인상은 항상 긍정적이다",
          "최저임금은 경제에 아무 영향을 미치지 않는다",
          "최저임금 정책은 장단점을 모두 고려해야 한다",
          "기업의 인건비 부담은 중요하지 않다"
        ],
        correct: 2,
        explanation: "글에서 최저임금 인상의 긍정적 효과(근로자 소득 증가)와 부정적 우려(고용 감소, 가격 인상)를 모두 제시하고, 마지막에 '균형을 고려하여 신중하게 결정해야 한다'고 했습니다. 따라서 최저임금 정책은 장단점을 모두 고려해야 함을 추론할 수 있습니다."
      },
      {
        category: "경제",
        skill: "비판 적용력",
        passage: "가상화폐는 블록체인 기술을 기반으로 한 디지털 자산이다. 중앙은행이나 정부의 통제를 받지 않아 자유로운 거래가 가능하다는 장점이 있다. 그러나 가격 변동성이 매우 크고, 해킹이나 사기 위험이 있으며, 법적 보호가 미흡하다는 단점도 있다. 일부 국가는 가상화폐를 규제하거나 금지하기도 한다. 가상화폐에 투자할 때는 위험성을 충분히 인지하고, 여유 자금으로만 투자해야 한다.",
        question: "가상화폐 투자 시 고려해야 할 사항으로 적절하지 않은 것은?",
        options: [
          "높은 가격 변동성 인지",
          "해킹과 사기 위험 파악",
          "생활비를 모두 투자하기",
          "법적 보호 수준 확인"
        ],
        correct: 2,
        explanation: "글의 마지막 문장에서 '여유 자금으로만 투자해야 한다'고 명확히 권고하고 있습니다. 가상화폐는 가격 변동성이 크고 위험이 많으므로 생활비를 모두 투자하는 것은 매우 위험하며 적절하지 않은 행동입니다."
      },

      // ========== 법 (21-25) ==========
      {
        category: "법",
        skill: "핵심 이해력",
        passage: "우리나라 헌법 제10조는 '모든 국민은 인간으로서의 존엄과 가치를 가지며, 행복을 추구할 권리를 가진다'고 규정한다. 이는 헌법상 기본권의 출발점으로, 개인의 인격권과 자기결정권을 보장하는 근거가 된다. 국가는 국민의 기본적 인권을 확인하고 보장할 의무가 있으며, 이는 단순히 침해하지 않는 소극적 의무뿐 아니라 적극적으로 실현할 의무를 포함한다. 인간의 존엄성은 어떤 경우에도 제한될 수 없는 절대적 가치로 인정된다.",
        question: "이 글이 설명하는 헌법 제10조의 핵심 내용은?",
        options: [
          "국가의 통치 구조",
          "인간의 존엄과 가치, 행복추구권",
          "재산권 보장",
          "교육의 의무"
        ],
        correct: 1,
        explanation: "글의 첫 문장에서 헌법 제10조가 '인간으로서의 존엄과 가치, 행복을 추구할 권리'를 규정한다고 명확히 밝히고 있습니다. 이것이 헌법상 기본권의 출발점이며, 이 조항의 핵심 내용입니다."
      },
      {
        category: "법",
        skill: "구조 파악력",
        passage: "형법의 기본 원칙 중 하나는 '죄형법정주의'다. 이는 법률에 명시되지 않은 행위는 처벌할 수 없다는 원칙으로, 국민의 자유와 권리를 보호한다. 죄형법정주의는 '법률이 없으면 범죄도 형벌도 없다'는 라틴어 격언으로 표현된다. 이 원칙은 국가 권력의 자의적인 형벌권 행사를 막고, 국민에게 법적 안정성과 예측 가능성을 제공한다. 따라서 법률은 명확하게 규정되어야 하며, 소급 적용되어서는 안 된다.",
        question: "이 글의 내용 전개 방식은?",
        options: [
          "원칙 제시 → 의미 설명 → 목적 및 요건 설명",
          "문제 제기 → 해결책 제시 → 예상 결과",
          "주장 → 반론 → 재반론 → 결론",
          "시대별 변화 과정 나열"
        ],
        correct: 0,
        explanation: "글은 먼저 '죄형법정주의'라는 원칙을 제시하고, 그 의미(법률에 없는 행위는 처벌 불가)를 설명합니다. 이어서 그 목적(권력 남용 방지, 법적 안정성 제공)과 요건(법률의 명확성, 소급 적용 금지)을 설명하는 구조입니다."
      },
      {
        category: "법",
        skill: "어휘 맥락력",
        passage: "계약은 당사자 간의 합의로 법적 효력이 발생하는 약속이다. 계약이 성립하려면 청약과 승낙이 있어야 하며, 당사자는 계약 내용을 이행할 의무를 진다. 만약 한쪽이 계약을 위반하면 손해배상 책임을 질 수 있다. 그러나 사기, 강박, 착오 등으로 체결된 계약은 취소할 수 있다. 계약은 사회 경제 활동의 기초이며, 신의성실 원칙에 따라 이행되어야 한다.",
        question: "문맥상 '이행하다'의 의미로 가장 적절한 것은?",
        options: [
          "취소하다",
          "실행하거나 수행하다",
          "거부하다",
          "연기하다"
        ],
        correct: 1,
        explanation: "문맥상 '계약 내용을 이행할 의무'와 '신의성실 원칙에 따라 이행되어야 한다'는 것은 계약에서 약속한 내용을 실제로 실행하거나 수행해야 한다는 의미입니다. 계약 위반의 반대 개념으로 계약을 지키는 것을 의미합니다."
      },
      {
        category: "법",
        skill: "추론 통합력",
        passage: "개인정보 보호법은 개인의 정보를 보호하고, 정보 주체의 권리를 보장하기 위한 법률이다. 개인정보를 수집할 때는 반드시 본인의 동의를 받아야 하며, 목적 외 사용을 금지한다. 위반 시 벌금이나 징역형에 처해질 수 있다. 최근 빅데이터와 인공지능 기술이 발전하면서 개인정보 유출과 악용 위험이 커지고 있어, 법적 규제와 기술적 보안이 더욱 중요해지고 있다.",
        question: "이 글로부터 추론할 수 있는 내용은?",
        options: [
          "개인정보는 동의 없이 자유롭게 사용할 수 있다",
          "기술 발전과 함께 개인정보 보호의 중요성이 커지고 있다",
          "개인정보 유출은 법적 처벌 대상이 아니다",
          "개인정보 보호법은 기업에만 적용된다"
        ],
        correct: 1,
        explanation: "글의 마지막 문장에서 빅데이터와 인공지능 기술이 발전하면서 개인정보 유출과 악용 위험이 커지고 있어 법적 규제와 기술적 보안이 더욱 중요해지고 있다고 설명합니다. 이를 통해 기술 발전과 함께 개인정보 보호의 중요성이 커지고 있음을 추론할 수 있습니다."
      },
      {
        category: "법",
        skill: "비판 적용력",
        passage: "노동법은 근로자의 권리를 보호하고, 노사 관계를 규율하는 법률이다. 근로기준법은 최저임금, 근로시간, 휴가, 해고 등에 관한 기준을 정한다. 근로자는 부당 해고나 임금 체불 시 노동위원회나 법원에 구제를 신청할 수 있다. 또한 노동조합을 결성하여 단체교섭을 할 권리가 있다. 그러나 현실에서는 비정규직 차별, 장시간 노동 등의 문제가 여전히 존재한다.",
        question: "노동법의 취지를 실생활에 적용한 사례로 적절하지 않은 것은?",
        options: [
          "부당 해고 시 노동위원회에 구제 신청",
          "임금 체불 시 법적 대응",
          "근로 시간을 무제한으로 연장하기",
          "노동조합을 통한 권리 보호"
        ],
        correct: 2,
        explanation: "노동법은 근로시간에 관한 기준을 정하여 근로자를 보호하는 법입니다. 글의 마지막 문장에서 '장시간 노동'을 여전히 존재하는 문제로 지적하고 있으므로, 근로 시간을 무제한으로 연장하는 것은 노동법의 취지에 어긋나는 부적절한 사례입니다."
      }
    ];

    // URL 파라미터에서 ID 가져오기
    const urlParams = new URLSearchParams(window.location.search);
    const applicationId = urlParams.get('id');

    async function loadTestResult() {
      if (!applicationId) {
        showError('시험지 ID가 없습니다.');
        return;
      }

      try {
        const response = await fetch(`/api/course-application/${applicationId}`);
        const result = await response.json();

        if (!result.success) {
          showError(result.message || '시험지를 불러올 수 없습니다.');
          return;
        }

        const data = result.data;

        // 답안이 없는 경우
        if (!data.answers || data.answers.length === 0) {
          showError('저장된 답안 정보가 없습니다.');
          return;
        }

        renderResult(data);
      } catch (error) {
        console.error('시험지 로드 오류:', error);
        showError('시험지를 불러오는 중 오류가 발생했습니다.');
      }
    }

    function showError(message) {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('error').style.display = 'block';
      document.getElementById('error').textContent = message;
    }

    function renderResult(data) {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('content').style.display = 'block';

      // 학생 정보 표시
      const gradeClass = `grade-${data.grade}`;
      document.getElementById('studentInfo').innerHTML = `
        <span class="info-badge name">${data.studentName}</span>
        <span class="info-badge grade">${data.studentGrade}</span>
        <span class="info-badge result-grade ${gradeClass}">${data.grade}등급</span>
        <span class="info-badge score">${data.score}/25점</span>
      `;

      // 정답/오답 개수 계산 및 스킬별/과목별 점수 계산
      let correctCount = 0;
      let wrongCount = 0;
      const skillScores = {
        "핵심 이해력": 0,
        "구조 파악력": 0,
        "어휘 맥락력": 0,
        "추론 통합력": 0,
        "비판 적용력": 0
      };
      const categoryScores = {
        "사회": 0,
        "과학": 0,
        "인문": 0,
        "경제": 0,
        "법": 0
      };

      data.answers.forEach((userAnswer, index) => {
        if (index < quizData.length) {
          const isCorrect = userAnswer === quizData[index].correct;
          if (isCorrect) {
            correctCount++;
            // 스킬별 점수 추가
            const skill = quizData[index].skill;
            if (skillScores.hasOwnProperty(skill)) {
              skillScores[skill]++;
            }
            // 과목별 점수 추가
            const category = quizData[index].category;
            if (categoryScores.hasOwnProperty(category)) {
              categoryScores[category]++;
            }
          } else {
            wrongCount++;
          }
        }
      });

      // 스킬별 퍼센트 계산 (각 스킬당 5문제)
      const skillPercentages = {};
      for (const skill in skillScores) {
        skillPercentages[skill] = (skillScores[skill] / 5) * 100;
      }

      // 과목별 퍼센트 계산 (각 과목당 5문제)
      const categoryPercentages = {};
      for (const category in categoryScores) {
        categoryPercentages[category] = (categoryScores[category] / 5) * 100;
      }

      // 가장 높은/낮은 스킬 찾기
      let highestSkill = Object.keys(skillScores)[0];
      let lowestSkill = Object.keys(skillScores)[0];
      for (const skill in skillScores) {
        if (skillScores[skill] > skillScores[highestSkill]) highestSkill = skill;
        if (skillScores[skill] < skillScores[lowestSkill]) lowestSkill = skill;
      }

      // 분석 결과 계산
      const score = data.score || correctCount;
      let series, recommendation, strength, weakness;

      if (score >= 24) {
        series = "BRAIN 딥";
        recommendation = "고급 수준의 문해력을 갖추셨습니다. BRAIN 딥 시리즈로 더 깊은 사고력을 키워보세요!";
        strength = `${highestSkill} 영역이 특히 뛰어납니다 (정답률 ${skillPercentages[highestSkill]}%). 복잡한 문맥을 이해하는 능력이 탁월합니다.`;
        weakness = skillScores[lowestSkill] < 4 ? `${lowestSkill} 영역을 더 강화하면 완벽합니다!` : "현재 수준을 유지하며, 더 다양한 장르의 텍스트를 접해보세요.";
      } else if (score >= 20) {
        series = "BRAIN 핏";
        recommendation = "추론력과 이해력이 고르게 발달했습니다. BRAIN 핏 시리즈로 균형 잡힌 문해력을 완성하세요!";
        strength = `${highestSkill} 영역이 우수합니다 (정답률 ${skillPercentages[highestSkill]}%). 기본적인 독해 능력이 탄탄합니다.`;
        weakness = `${lowestSkill} 영역에서 조금 더 연습이 필요합니다 (정답률 ${skillPercentages[lowestSkill]}%).`;
      } else if (score >= 17) {
        series = "BRAIN 업";
        recommendation = "기초 이해력은 있습니다. BRAIN 업 시리즈로 추론력과 사고력을 한 단계 더 키워보세요!";
        strength = `${highestSkill} 영역에서 가능성이 보입니다 (정답률 ${skillPercentages[highestSkill]}%).`;
        weakness = `${lowestSkill} 영역을 집중 학습하면 큰 발전이 있을 것입니다 (정답률 ${skillPercentages[lowestSkill]}%).`;
      } else {
        series = "BRAIN 온";
        recommendation = "문해력 기초를 탄탄히 다질 시간입니다. BRAIN 온 시리즈로 기초부터 차근차근 시작하세요!";
        strength = "학습 의지가 있으며, 앞으로 발전 가능성이 높습니다.";
        weakness = "5가지 문해력 지수를 모두 기초부터 차근차근 쌓아가는 것이 필요합니다.";
      }

      // 추천 시리즈 및 분석 결과 표시
      document.getElementById('recommendedSeries').textContent = series;
      document.getElementById('recommendationText').textContent = recommendation;
      document.getElementById('strengthText').textContent = strength;
      document.getElementById('weaknessText').textContent = weakness;

      // 레이더 차트 그리기
      drawRadarChart(skillPercentages);

      // 문해력 지수별 막대 그래프 그리기
      drawSkillBarChart(skillPercentages, data.studentGrade);

      // 과목별 막대 그래프 그리기
      drawCategoryBarChart(categoryPercentages, data.studentGrade);

      // AI 피드백용 데이터 저장 (전역)
      const studentGradeForFeedback = data.studentGrade || '초5';
      window.aiFeedbackData = {
        studentName: data.studentName || '학생',
        studentGrade: studentGradeForFeedback,
        skillPercentages: skillPercentages,
        categoryPercentages: categoryPercentages,
        gradeAverage: getGradeAverage(studentGradeForFeedback).avg,
        totalScore: correctCount
      };

      // AI 피드백 로드
      loadAIFeedback();
      console.log('AI 피드백 데이터:', window.aiFeedbackData);

      // 요약 정보
      document.getElementById('summary').innerHTML = `
        <div class="summary-item">
          <div class="label">정답</div>
          <div class="value correct">${correctCount}개</div>
        </div>
        <div class="summary-item">
          <div class="label">오답</div>
          <div class="value wrong">${wrongCount}개</div>
        </div>
        <div class="summary-item">
          <div class="label">응시일</div>
          <div class="value">${new Date(data.createdAt).toLocaleDateString('ko-KR')}</div>
        </div>
        ${data.duration ? `<div class="summary-item">
          <div class="label">소요시간</div>
          <div class="value">${data.duration}</div>
        </div>` : ''}
      `;

      // 틀린 문항 배지 렌더링
      const wrongQuestions = [];
      data.answers.forEach((userAnswer, index) => {
        if (index >= quizData.length) return;
        const q = quizData[index];
        if (userAnswer !== q.correct) {
          wrongQuestions.push(index + 1);
        }
      });

      if (wrongQuestions.length > 0) {
        document.getElementById('wrongQuestionsNav').style.display = 'block';
        const wrongBadgesHTML = wrongQuestions.map(num =>
          `<a href="#question-${num}" class="wrong-badge" onclick="scrollToQuestion(${num})">${num}</a>`
        ).join('');
        document.getElementById('wrongBadges').innerHTML = wrongBadgesHTML;
      }

      // 문제 목록 렌더링
      let questionsHTML = '';
      data.answers.forEach((userAnswer, index) => {
        if (index >= quizData.length) return;

        const q = quizData[index];
        const isCorrect = userAnswer === q.correct;
        const statusClass = isCorrect ? 'correct' : 'wrong';
        const statusIcon = isCorrect ? '✅' : '❌';

        let optionsHTML = '';
        q.options.forEach((option, optIdx) => {
          let optionClass = '';
          let marker = '';

          if (optIdx === q.correct && optIdx === userAnswer) {
            // 정답이면서 학생이 선택한 답
            optionClass = 'user-correct';
            marker = '✅ 정답 (내 선택)';
          } else if (optIdx === q.correct) {
            // 정답
            optionClass = 'correct-answer';
            marker = '✅ 정답';
          } else if (optIdx === userAnswer) {
            // 학생이 선택한 오답
            optionClass = 'user-wrong';
            marker = '❌ 내 선택';
          }

          optionsHTML += `
            <li class="option-item ${optionClass}">
              <span class="option-marker">${optIdx + 1}.</span>
              ${option}
              ${marker ? `<span style="float: right; font-weight: 600;">${marker}</span>` : ''}
            </li>
          `;
        });

        questionsHTML += `
          <div class="question-item ${statusClass}" id="question-${index + 1}">
            <div class="question-header">
              <span class="question-number">문제 ${index + 1}</span>
              <div class="question-category">
                <span class="category-badge">${q.category}</span>
                <span class="skill-badge">${q.skill}</span>
              </div>
              <span class="result-icon">${statusIcon}</span>
            </div>
            <div class="passage-box">${q.passage}</div>
            <div class="question-text">${q.question}</div>
            <ul class="options-list">
              ${optionsHTML}
            </ul>
            <div class="explanation-box">
              <strong>해설:</strong> ${q.explanation}
            </div>
          </div>
        `;
      });

      document.getElementById('questionList').innerHTML = questionsHTML;
    }

    // 학년별 평균 계산 함수
    function getGradeAverage(studentGrade) {
      const grade = (studentGrade || '').toLowerCase();
      // 고등학생 먼저 체크 (고3에 '3'이 포함되어 초3으로 잘못 인식되는 것 방지)
      if (grade.includes('고2') || grade.includes('고3')) {
        return {
          avg: 80,
          label: '고2-3 평균',
          skills: {
            '핵심 이해력': 83,
            '구조 파악력': 88,
            '어휘 맥락력': 95,
            '추론 통합력': 85,
            '비판 적용력': 88
          },
          categories: {
            '사회': 90,
            '과학': 82,
            '인문': 90,
            '경제': 82,
            '법': 88
          }
        };
      } else if (grade.includes('중3') || grade.includes('고1')) {
        return {
          avg: 75,
          label: '중3-고1 평균',
          skills: {
            '핵심 이해력': 73,
            '구조 파악력': 78,
            '어휘 맥락력': 85,
            '추론 통합력': 85,
            '비판 적용력': 78
          },
          categories: {
            '사회': 80,
            '과학': 72,
            '인문': 80,
            '경제': 72,
            '법': 78
          }
        };
      } else if (grade.includes('중1') || grade.includes('중2')) {
        return {
          avg: 70,
          label: '중1-2 평균',
          skills: {
            '핵심 이해력': 73,
            '구조 파악력': 68,
            '어휘 맥락력': 85,
            '추론 통합력': 75,
            '비판 적용력': 78
          },
          categories: {
            '사회': 70,
            '과학': 62,
            '인문': 70,
            '경제': 62,
            '법': 68
          }
        };
      } else if (grade.includes('초5') || grade.includes('초6') || grade.includes('5') || grade.includes('6')) {
        return {
          avg: 60,
          label: '초5-6 평균',
          skills: {
            '핵심 이해력': 63,
            '구조 파악력': 58,
            '어휘 맥락력': 75,
            '추론 통합력': 65,
            '비판 적용력': 68
          },
          categories: {
            '사회': 65,
            '과학': 52,
            '인문': 60,
            '경제': 52,
            '법': 58
          }
        };
      } else if (grade.includes('초3') || grade.includes('초4') || grade.includes('3') || grade.includes('4')) {
        return {
          avg: 50,
          label: '초3-4 평균',
          skills: {
            '핵심 이해력': 53,
            '구조 파악력': 48,
            '어휘 맥락력': 70,
            '추론 통합력': 55,
            '비판 적용력': 58
          },
          categories: {
            '사회': 60,
            '과학': 48,
            '인문': 55,
            '경제': 48,
            '법': 53
          }
        };
      }
      // 기본값 (학년 파악 불가 시) - 초5-6 기준
      return {
        avg: 60,
        label: '평균',
        skills: {
          '핵심 이해력': 63,
          '구조 파악력': 58,
          '어휘 맥락력': 75,
          '추론 통합력': 65,
          '비판 적용력': 68
        },
        categories: {
          '사회': 65,
          '과학': 52,
          '인문': 60,
          '경제': 52,
          '법': 58
        }
      };
    }

    // 문해력 지수별 막대 그래프 그리기 함수
    function drawSkillBarChart(skillPercentages, studentGrade) {
      const skills = [
        "핵심 이해력",
        "구조 파악력",
        "어휘 맥락력",
        "추론 통합력",
        "비판 적용력"
      ];

      const gradeAvg = getGradeAverage(studentGrade);

      let barsHTML = '';
      skills.forEach(skill => {
        const percent = skillPercentages[skill] || 0;
        const skillAvg = gradeAvg.skills[skill] || gradeAvg.avg; // 지수별 평균
        // 평균 기준선 대비 색상 결정
        let colorClass = 'poor';
        if (percent >= skillAvg + 20) colorClass = 'excellent';      // 평균보다 20% 이상 높음
        else if (percent >= skillAvg) colorClass = 'good';           // 평균 이상
        else if (percent >= skillAvg - 20) colorClass = 'average';   // 평균보다 20% 미만 낮음

        barsHTML += `
          <div class="skill-bar-item">
            <div class="skill-bar-label">
              <span class="name">${skill}</span>
              <span class="percent">${percent.toFixed(0)}%</span>
            </div>
            <div class="skill-bar-bg">
              <div class="skill-bar-fill ${colorClass}" style="width: ${percent}%;"></div>
              <div class="grade-avg-line" style="left: ${skillAvg}%;">
                <span class="grade-avg-label">${skillAvg}%</span>
              </div>
            </div>
          </div>
        `;
      });

      barsHTML += `
        <div class="grade-avg-info">
          <span class="avg-marker"></span>
          <span>${gradeAvg.label} 지수별 기준선</span>
        </div>
      `;

      document.getElementById('skillBarContainer').innerHTML = barsHTML;
    }

    // 과목별 막대 그래프 그리기 함수
    function drawCategoryBarChart(categoryPercentages, studentGrade) {
      const categories = [
        "사회",
        "과학",
        "인문",
        "경제",
        "법"
      ];

      const gradeAvg = getGradeAverage(studentGrade);

      let barsHTML = '';
      categories.forEach(category => {
        const percent = categoryPercentages[category] || 0;
        const categoryAvg = gradeAvg.categories[category] || gradeAvg.avg; // 과목별 평균
        // 평균 기준선 대비 색상 결정
        let colorClass = 'poor';
        if (percent >= categoryAvg + 20) colorClass = 'excellent';      // 평균보다 20% 이상 높음
        else if (percent >= categoryAvg) colorClass = 'good';           // 평균 이상
        else if (percent >= categoryAvg - 20) colorClass = 'average';   // 평균보다 20% 미만 낮음

        barsHTML += `
          <div class="skill-bar-item">
            <div class="skill-bar-label">
              <span class="name">${category}</span>
              <span class="percent">${percent.toFixed(0)}%</span>
            </div>
            <div class="skill-bar-bg">
              <div class="skill-bar-fill ${colorClass}" style="width: ${percent}%;"></div>
              <div class="grade-avg-line" style="left: ${categoryAvg}%;">
                <span class="grade-avg-label">${categoryAvg}%</span>
              </div>
            </div>
          </div>
        `;
      });

      barsHTML += `
        <div class="grade-avg-info">
          <span class="avg-marker"></span>
          <span>${gradeAvg.label} 과목별 기준선</span>
        </div>
      `;

      document.getElementById('categoryBarContainer').innerHTML = barsHTML;
    }

    // 레이더 차트 그리기 함수
    function drawRadarChart(skillPercentages) {
      const canvas = document.getElementById('radarChart');
      const ctx = canvas.getContext('2d');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 150;

      // 캔버스 초기화
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 5개 스킬 (순서대로)
      const skills = [
        "핵심 이해력",
        "구조 파악력",
        "어휘 맥락력",
        "추론 통합력",
        "비판 적용력"
      ];

      const angles = skills.map((_, i) => (Math.PI * 2 * i) / 5 - Math.PI / 2);

      // 배경 원 그리기 (20%, 40%, 60%, 80%, 100%)
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      for (let i = 1; i <= 5; i++) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, (radius * i) / 5, 0, Math.PI * 2);
        ctx.stroke();
      }

      // 축 선 그리기
      ctx.strokeStyle = '#cccccc';
      ctx.lineWidth = 1;
      angles.forEach(angle => {
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(
          centerX + Math.cos(angle) * radius,
          centerY + Math.sin(angle) * radius
        );
        ctx.stroke();
      });

      // 레이블 그리기
      ctx.fillStyle = '#2c3e50';
      ctx.font = 'bold 14px "Noto Sans KR", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      skills.forEach((skill, i) => {
        const angle = angles[i];
        const labelRadius = radius + 50;
        const x = centerX + Math.cos(angle) * labelRadius;
        const y = centerY + Math.sin(angle) * labelRadius;

        // 텍스트 위치 조정 - 모든 라벨 중앙 정렬
        ctx.textAlign = 'center';

        ctx.fillText(skill, x, y);
      });

      // 데이터 영역 그리기
      ctx.beginPath();
      ctx.strokeStyle = '#667eea';
      ctx.fillStyle = 'rgba(102, 126, 234, 0.2)';
      ctx.lineWidth = 3;

      skills.forEach((skill, i) => {
        const percentage = skillPercentages[skill] || 0;
        const angle = angles[i];
        const r = (radius * percentage) / 100;
        const x = centerX + Math.cos(angle) * r;
        const y = centerY + Math.sin(angle) * r;

        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });

      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // 데이터 점 그리기
      skills.forEach((skill, i) => {
        const percentage = skillPercentages[skill] || 0;
        const angle = angles[i];
        const r = (radius * percentage) / 100;
        const x = centerX + Math.cos(angle) * r;
        const y = centerY + Math.sin(angle) * r;

        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#667eea';
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();

        // 퍼센트 표시
        ctx.fillStyle = '#667eea';
        ctx.font = 'bold 12px "Noto Sans KR", sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`${percentage.toFixed(0)}%`, x, y - 15);
      });
    }

    // 페이지 로드 시 실행
    window.addEventListener('DOMContentLoaded', loadTestResult);

    // 현재 로드된 학생 정보 저장용
    let currentStudentData = null;

    // renderResult 함수에서 데이터 저장하도록 수정 (기존 renderResult 호출 시 데이터 저장)
    const originalRenderResult = renderResult;
    renderResult = function(data) {
      currentStudentData = data;
      originalRenderResult(data);
    };

    // 카카오 SDK 초기화
    if (typeof Kakao !== 'undefined' && !Kakao.isInitialized()) {
      Kakao.init('6ad10cc6680c7a5829a4fd7a3cbb4a7e');
    }

    // 틀린 문항 바로가기 스크롤 함수
    function scrollToQuestion(num) {
      const element = document.getElementById(`question-${num}`);
      if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // 하이라이트 효과
        element.style.boxShadow = '0 0 15px rgba(231, 76, 60, 0.5)';
        setTimeout(() => {
          element.style.boxShadow = '';
        }, 2000);
      }
    }

    // AI 피드백 로드 함수
    async function loadAIFeedback() {
      const loadingEl = document.getElementById('aiFeedbackLoading');
      const contentEl = document.getElementById('aiFeedbackContent');
      const errorEl = document.getElementById('aiFeedbackError');

      // 로딩 상태
      loadingEl.style.display = 'block';
      contentEl.style.display = 'none';
      errorEl.style.display = 'none';

      try {
        const feedbackData = window.aiFeedbackData;
        if (!feedbackData) {
          throw new Error('피드백 데이터가 없습니다.');
        }

        const response = await fetch('/api/literacy-test/ai-feedback', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(feedbackData)
        });

        const result = await response.json();

        if (!result.ok) {
          throw new Error(result.error || '피드백 생성 실패');
        }

        // 피드백 표시
        const feedback = result.feedback;
        document.getElementById('feedbackOverall').textContent = feedback.overall || '';
        document.getElementById('feedbackStrengths').textContent = feedback.strengths || '';
        document.getElementById('feedbackImprovements').textContent = feedback.improvements || '';
        document.getElementById('feedbackTips').textContent = feedback.tips || '';

        loadingEl.style.display = 'none';
        contentEl.style.display = 'block';

      } catch (err) {
        console.error('AI 피드백 로드 오류:', err);
        loadingEl.style.display = 'none';
        errorEl.style.display = 'block';
      }
    }

    // PDF 다운로드 기능
    async function downloadPDF() {
      const content = document.getElementById('content');
      if (!content) {
        alert('PDF 생성에 실패했습니다.');
        return;
      }

      // 로딩 표시
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'pdfLoading';
      loadingDiv.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 9999; color: white; font-size: 18px;';
      loadingDiv.innerHTML = '<div style="text-align: center;"><div style="margin-bottom: 10px;">PDF 생성 중...</div><div style="font-size: 14px;">잠시만 기다려주세요</div></div>';
      document.body.appendChild(loadingDiv);

      try {
        const { jsPDF } = window.jspdf;

        // html2canvas로 화면 캡처 (품질 낮춤으로 용량 감소)
        const canvas = await html2canvas(content, {
          scale: 1.5, // 품질 낮춤 (기본 2)
          useCORS: true,
          logging: false,
          backgroundColor: '#ffffff'
        });

        const imgData = canvas.toDataURL('image/jpeg', 0.7); // JPEG로 변환하여 용량 감소
        const imgWidth = 210; // A4 가로
        const pageHeight = 297; // A4 세로
        const imgHeight = canvas.height * imgWidth / canvas.width;

        const pdf = new jsPDF('p', 'mm', 'a4');

        let heightLeft = imgHeight;
        let position = 0;

        // 첫 페이지
        pdf.addImage(imgData, 'JPEG', 0, position, imgWidth, imgHeight, undefined, 'FAST');
        heightLeft -= pageHeight;

        // 다음 페이지들
        while (heightLeft > 0) {
          position = heightLeft - imgHeight;
          pdf.addPage();
          pdf.addImage(imgData, 'JPEG', 0, position, imgWidth, imgHeight, undefined, 'FAST');
          heightLeft -= pageHeight;
        }

        // 학생 정보 기반 파일명
        const studentName = currentStudentData?.studentName || '학생';
        const studentGrade = currentStudentData?.studentGrade || '';
        const dateStr = new Date().toLocaleDateString('ko-KR').replace(/\./g, '').replace(/ /g, '');

        pdf.save(`문해력진단_시험지_${studentGrade}_${studentName}_${dateStr}.pdf`);
      } catch (error) {
        console.error('PDF 생성 오류:', error);
        alert('PDF 생성 중 오류가 발생했습니다.');
      } finally {
        // 로딩 제거
        document.getElementById('pdfLoading')?.remove();
      }
    }

    // 카카오톡 전송 기능
    function sendKakao() {
      if (typeof Kakao === 'undefined') {
        alert('카카오톡 SDK를 불러오는 중입니다.\n잠시 후 다시 시도해주세요.');
        return;
      }

      if (!Kakao.isInitialized()) {
        Kakao.init('6ad10cc6680c7a5829a4fd7a3cbb4a7e');
      }

      const studentName = currentStudentData?.studentName || '학생';
      const studentGrade = currentStudentData?.studentGrade || '';
      const gradeResult = currentStudentData?.grade || '';
      const score = currentStudentData?.score || 0;

      // 현재 시험지 URL (ID 포함) - Render 서버 URL 사용 (로그인 없이 접근 가능)
      const resultUrl = `https://dan-dan-app.onrender.com/test-result-viewer.html?id=${applicationId}`;

      Kakao.Link.sendDefault({
        objectType: 'feed',
        content: {
          title: '📝 단단국어 문해력 진단 시험지',
          description: `${studentGrade} ${studentName} 학생\n등급: ${gradeResult}\n점수: ${score}/25점\n전체 문제 정답 및 해설 확인하기`,
          imageUrl: 'https://dan-dan-app.web.app/images/kakao_share.png',
          link: {
            mobileWebUrl: resultUrl,
            webUrl: resultUrl
          }
        },
        buttons: [
          {
            title: '진단결과보기',
            link: {
              mobileWebUrl: resultUrl,
              webUrl: resultUrl
            }
          }
        ]
      });
    }

    // 맨 위로 가기 버튼 기능
    window.addEventListener('scroll', () => {
      const scrollToTopBtn = document.getElementById('scrollToTopBtn');
      if (scrollToTopBtn) {
        if (window.scrollY > 300) {
          scrollToTopBtn.classList.add('visible');
        } else {
          scrollToTopBtn.classList.remove('visible');
        }
      }
    });

    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  </script>

  <!-- 맨 위로 가기 버튼 -->
  <button class="scroll-to-top" id="scrollToTopBtn" onclick="scrollToTop()" title="맨 위로">
    ↑
  </button>
</body>
</html>
